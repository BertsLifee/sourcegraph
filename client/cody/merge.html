<!DOCTYPE html>
<title>NST Merge Experiment</title>
<style>
#layout {
    display: flex;
    flex-wrap: wrap;
}

#layout > p {
    flex: 0.33;
    background: hsla(31, 15%, 50%, 0.1);
    padding: 0.75em;
    box-sizing: border-box;
    margin: 0.25em;
}

#layout > #merged {
    flex: 1;
    font-family: monospace;
}

.robot {
    background-color: aquamarine;
}

.human {
    background-color: yellow;
}

.conflict {
    color: yellow;
    background: orangered;
}
</style>
<div id="layout">

<p>
<label for="original">Original:</label><br>
<textarea id="original" rows="20" cols="60"></textarea>
</p>

<p>
<label for="robot">Robot:</label><br>
<textarea id="robot" rows="20" cols="60"></textarea>
</p>

<p>
<label for="human">Human:</label><br>
<textarea id="human" rows="20" cols="60"></textarea>
</p>

<pre id="merged">
merged <span class="insertion">con-
    tent</span> g<span class="conflict">oe</span>s <span class="deletion">here</span>
</pre>

</div>

<script>

function time(label, f) {
    const start = performance.now();
    const result = f();
    const end = performance.now();
    console.log(label, end - start, 'msec');
    return result;
}

// More computationally intensive approaches may scale by first
// working at the line level, and then working within a line.
// It may be necessary to understand some structural edits like
// "indent".

// Computes the longest common subsequence of strings a and b.
// Returns a boolean program of |b|+1 rows and |a|+1 columns in
// row-major format. The 0th row and column can be ignored. If
// the program[i, j] is true then the longest common subsequence
// of a and b uses b[i-1] and a[j-1]. 
function longestCommonSubsequence(a, b) {
    // Construct a dynamic program of edits.
    const lenA = a.length;
    const lenB = b.length;
    const program = new Uint16Array((lenA + 1) * (lenB + 1));
    // TODO: Use a cheaper representation than strings for the operations.
    const ops = new Array((lenA + 1) * (lenB + 1));
    ops[0] = '*';
    // Top row: Delete all of the characters in A.
    for (let i = 1; i <= lenA; i++) {
        program[i] = i;
        ops[i] = 'X';
    }
    // Left column: Insert all of the characters in B.
    for (let i = 1; i <= lenB; i++) {
        program[i * (lenA + 1)] = i;
        ops[i * (lenA + 1)] = 'I';
    }
    for (let iB = 1; iB <= lenB; iB++) {
        const chB = b[iB - 1];
        for (let iA = 1; iA <= lenA; iA++) {
            const chA = a[iA - 1];
            const costDeleteA = program[iB * (lenA + 1) + iA - 1] + 1;
            const costInsertB = program[(iB - 1) * (lenA + 1) + iA] + 1;
            const costSkipReplace = program[(iB - 1) * (lenA + 1) + iA - 1] + (chA == chB ? 0 : 1);
            const cost = Math.min(costDeleteA, costInsertB, costSkipReplace);
            program[iB * (lenA + 1) + iA] = cost;
            ops[iB * (lenA + 1) + iA] = cost === costDeleteA ? 'X' : (cost === costInsertB ? 'I' : (chA === chB ? '-' : 'R'));
        }
    }
    // dumpProgram(program, ops, a, b);
    const use = new Uint8Array((lenA + 1) * (lenB + 1));
    let i = lenA;
    let j = lenB;
    while (i != 0 || j != 0) {
        switch (ops[j * (lenA + 1) + i]) {
        case '-':
            use[j * (lenA + 1) + i] = 1;
            i--;
            j--;
            break;
        case 'R':
            i--;
            j--;
            break;
        case 'X':
            i--;
            break;
        case 'I':
            j--;
            break;
        default:
            throw new Error('unreachable');
        }
    }
    // The total cost
    // return program[program.length - 1];
    return use;
}

function dumpProgram(program, ops, a, b) {
    const buffer = [];
    buffer.push(`  ^${a}\n`);
    for (let iB = 0; iB <= b.length; iB++) {
        buffer.push(`${iB == 0 ? '^' : b[iB-1]}|`)
        for (let iA = 0; iA <= a.length; iA++) {
            buffer.push(program[iB * (a.length + 1) + iA].toString(26).slice(0, 1))
        }
        buffer.push('\n')
    }
    buffer.push(`  ^${a}\n`);
    for (let iB = 0; iB <= b.length; iB++) {
        buffer.push(`${iB == 0 ? '^' : b[iB-1]}|`)
        for (let iA = 0; iA <= a.length; iA++) {
            buffer.push(ops[iB * (a.length + 1) + iA])
        }
        buffer.push('\n')
    }
    console.log(buffer.join(''))
}

function dumpUse(use, a, b) {
    const buffer = [];
    buffer.push(`  ^${a}\n`);
    for (let iB = 0; iB <= b.length; iB++) {
        buffer.push(`${iB == 0 ? '^' : b[iB-1]}|`)
        for (let iA = 0; iA <= a.length; iA++) {
            buffer.push(use[iB * (a.length + 1) + iA].toString())
        }
        buffer.push('\n')
    }
    console.log(buffer.join(''))
}

function stateChanged() {
    const chunks = time('recompute', () => computeChunks(original.value, robot.value, human.value));
    for (let chunk of chunks) {
        console.log(chunk)
    }
    merged.textContent = '';
    for (let chunk of chunks) {
        let text;
        let klass;
        if (chunk[1] == chunk[2] && chunk[0] != chunk[1]) {
            // Changed by robot
            text = chunk[0];
            klass = 'robot';
        } else if (chunk[1] == chunk[0] && chunk[1] != chunk[2]) {
            // Changed by human
            text = chunk[2];
            klass = 'human';
        } else if (chunk[0] == chunk[2]) {
            // Changed by both, to the same thing
            text = chunk[0];
            klass = '';
        } else {
            // Conflict!
            text = `<${chunk[0]}/${chunk[2]}>`;
            klass = 'conflict';
        }
        let node = document.createElement('span');
        node.textContent = text;
        if (klass) {
            node.classList.toggle(klass);
        }
        merged.appendChild(node);
    }
}

function computeChunks(original, a, b) {
    const useA = longestCommonSubsequence(original, a);
    // dumpUse(useA, original, a);
    const useB = longestCommonSubsequence(original, b);
    // dumpUse(useB, original, b);
    let chunks = [];
    let lO = 0;
    let lA = 0;
    let lB = 0;
    outer: while (true) {
        for (let i = 1; lO + i <= original.length && (lA + i <= a.length || lB + i <= b.length); i++) {
            if ((lA + i <= a.length && useA[(lA + i) * (original.length + 1) + lO + i]) &&
                (lB + i <= b.length && useB[(lB + i) * (original.length + 1) + lO + i])) {
                // Skipping stable pieces.
                continue;
            }
            if (i > 1) {
                // We found a stable chunk.
                chunks.push([a.slice(lA, lA + i - 1), original.slice(lO, lO + i - 1), b.slice(lB, lB + i - 1)]);
                lO += i - 1;
                lA += i - 1;
                lB += i - 1;
                continue outer;
            }
            // i === 1
            // Skipping unstable pieces.
            for (let nextO = lO + 1; nextO <= original.length; nextO++) {
                // Find an A
                let nextA, nextB;
                for (nextA = 1; nextA <= a.length; nextA++) {
                    if (useA[nextA * (original.length + 1) + nextO]) {
                        break;
                    }
                }
                if (nextA > a.length) {
                    continue;
                }
                // Find a B
                for (nextB = 1; nextB <= b.length; nextB++) {
                    if (useB[nextB * (original.length + 1) + nextO]) {
                        break;
                    }
                }
                if (nextB > b.length) {
                    continue;
                }
                // Output an unstable chunk
                chunks.push([a.slice(lA, nextA - 1), original.slice(lO, nextO - 1), b.slice(lB, nextB - 1)]);
                lO = nextO - 1;
                lA = nextA - 1;
                lB = nextB - 1;
                continue outer;
            }
            break outer;
        }
        break;
    }
    if (lO <= original.length || lA <= a.length || lB <= b.length) {
        chunks.push([a.slice(lA), original.slice(lO), b.slice(lB)])
    }
    return chunks;
}

original.addEventListener('change', stateChanged);
robot.addEventListener('change', stateChanged);
human.addEventListener('change', stateChanged);

</script>