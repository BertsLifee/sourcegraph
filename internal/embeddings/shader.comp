#version 450 core

// CUDA to GLSL magic constants:
// ----------------------------------
// CUDA      | GLSL                 |
// ----------------------------------
// blockIdx  | gl_WorkGroupID       |
// blockDim  | gl_WorkGroupSize     |
// threadIdx | gl_LocalInvocationID |
// ----------------------------------

// GLSL magic constants
// gl_GlobalInovocationID: global among all workgroups
//     = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID
// gl_LocalInvocationIndex: local within workgroup
// gl_WorkGroupID: ID of current workgroup, useful for offsets within workgroup-shared data
// gl_WorkGroupSize: size of workgroup, as defined in the below layout declaration

layout (/* gl_WorkGroupSize.x */ local_size_x = 1024) in;

layout(std430, binding = 0) readonly buffer A {
    uint a[];
};

layout(std430, binding = 1) readonly buffer B {
    uint b[];
};

layout(binding = 2) writeonly buffer C {
    int result[];
};

// unpacks 4 twos-complement int8s from a uint
ivec4 unpack(uint data) {
  int a = int(data & 0xFF);
  a = a - (a >> 7) * 256;

  int b = int((data >> 8) & 0xFF);
  b = b - (b >> 7) * 256;

  int c = int((data >> 16) & 0xFF);
  c = c - (c >> 7) * 256;

  int d = int((data >> 24) & 0xFF);
  d = d - (d >> 7) * 256;

  return ivec4(a, b, c, d);
}

shared int reduce[gl_WorkGroupSize.x];

void main() {
    uint global_id = gl_GlobalInvocationID.x;
    uint local_id  = gl_LocalInvocationID.x;

    if (global_id >= a.length()) return;

    ivec4 mult = unpack(a[global_id]) * unpack(b[global_id]);
    reduce[local_id] = mult.x + mult.y + mult.z + mult.w;

    barrier();

    // from pages 14-16 of the great "Optimizing Parallel Reduction in CUDA" paper by NVIDIA
    // https://developer.download.nvidia.com/assets/cuda/files/reduction.pdf
    for (uint i = gl_WorkGroupSize.x / 2; i > 0; i >>= 1) {
        if (local_id < i) {
            reduce[local_id] += reduce[local_id + i];
        }
        barrier();
    }

    if (local_id == 0) result[gl_WorkGroupID.x] = reduce[0];
}
